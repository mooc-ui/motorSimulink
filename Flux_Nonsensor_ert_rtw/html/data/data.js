var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Flux_Nonsensor","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"主文件","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"Flux_Nonsensor.h\"            /* Model header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  Flux_Nonsensor_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example main function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific. This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  Flux_Nonsensor_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 1.0E-6 seconds (base rate of the model) here.\r\n   * The call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Flux_Nonsensor.c","type":"source","group":"model","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * File: Flux_Nonsensor.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Flux_Nonsensor.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Flux_Nonsensor_private.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"speed_control.h\"\r\n#include \"global_mcu_adc_isr.h\"\r\n#include <float.h>\r\n\r\n/* user code (top of source file) */\r\n/* System '<Root>/FOC电机控制' */\r\nextern float Bus_volt_V,Ia_A,Ib_A,Ic_A,motor_angle;\r\nextern int16_T motor_rotate_speed_rpm_resolver;\r\nextern uint16_T motor_angle_elec_uint_resolver;\r\nextern int16_T vcu_send_speed;\r\nextern real32_T motor_rpm_ref;\r\nextern TIM_HandleTypeDef htim1;\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nstatic void rate_scheduler(void);\r\n\r\n/*\r\n *         This function updates active task flag for each subrate.\r\n *         The function is called at model base rate, hence the\r\n *         generated code self-manages all its subrates.\r\n */\r\nstatic void rate_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (rtM->Timing.TaskCounters.TID[1])++;\r\n  if ((rtM->Timing.TaskCounters.TID[1]) > 24) {/* Sample time: [2.5E-5s, 0.0s] */\r\n    rtM->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n\r\n  (rtM->Timing.TaskCounters.TID[2])++;\r\n  if ((rtM->Timing.TaskCounters.TID[2]) > 99) {/* Sample time: [0.0001s, 0.0s] */\r\n    rtM->Timing.TaskCounters.TID[2] = 0;\r\n  }\r\n}\r\n\r\n/* Output and update for atomic system: '<S15>/Sine_Cosine' */\r\nvoid Sine_Cosine(void)\r\n{\r\n  real32_T rtb_Saturation;\r\n\r\n  /* Saturate: '<S17>/Saturation' */\r\n  if (ObserverTheta > 6.28218508F) {\r\n    rtb_Saturation = 6.28218508F;\r\n  } else if (ObserverTheta < 0.001F) {\r\n    rtb_Saturation = 0.001F;\r\n  } else {\r\n    rtb_Saturation = ObserverTheta;\r\n  }\r\n\r\n  /* End of Saturate: '<S17>/Saturation' */\r\n\r\n  /* Trigonometry: '<S17>/Cos1' */\r\n  rtDW.Cos1 = cosf(rtb_Saturation);\r\n\r\n  /* Trigonometry: '<S17>/Sin1' */\r\n  rtDW.Sin1 = sinf(rtb_Saturation);\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/InvPark' */\r\nvoid InvPark(real32_T rtu_d, real32_T rtu_q, const real32_T rtu_SinCos[2],\r\n             real32_T *rty_alpha, real32_T *rty_beta)\r\n{\r\n  /* Product: '<S8>/Product' */\r\n  *rty_alpha = rtu_d * rtu_SinCos[1];\r\n\r\n  /* Product: '<S8>/Product1' */\r\n  *rty_beta = rtu_q * rtu_SinCos[0];\r\n\r\n  /* Sum: '<S8>/Sum' */\r\n  *rty_alpha -= *rty_beta;\r\n\r\n  /* Product: '<S8>/Product2' */\r\n  *rty_beta = rtu_d * rtu_SinCos[0];\r\n\r\n  /* Sum: '<S8>/Sum1' incorporates:\r\n   *  Product: '<S8>/Product3'\r\n   */\r\n  *rty_beta += rtu_q * rtu_SinCos[1];\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/Park' */\r\nvoid Park(real32_T rtu_Alpha, real32_T rtu_Beta, const real32_T rtu_SinCos[2],\r\n          real32_T *rty_D, real32_T *rty_Q)\r\n{\r\n  /* Product: '<S9>/Product' */\r\n  *rty_D = rtu_Alpha * rtu_SinCos[1];\r\n\r\n  /* Product: '<S9>/Product1' */\r\n  *rty_Q = rtu_Beta * rtu_SinCos[0];\r\n\r\n  /* Sum: '<S9>/Sum' */\r\n  *rty_D += *rty_Q;\r\n\r\n  /* Product: '<S9>/Product2' */\r\n  *rty_Q = rtu_Alpha * rtu_SinCos[0];\r\n\r\n  /* Sum: '<S9>/Sum1' incorporates:\r\n   *  Product: '<S9>/Product3'\r\n   */\r\n  *rty_Q = rtu_Beta * rtu_SinCos[1] - *rty_Q;\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/SVPWM1' */\r\nvoid SVPWM1(real32_T rtu_Valpha, real32_T rtu_Vbeta, real32_T rtu_v_bus,\r\n            real32_T rty_tABC[3])\r\n{\r\n  real32_T rtb_Min;\r\n  real32_T rtb_Sum1_b;\r\n  real32_T rtb_Sum_i;\r\n\r\n  /* Gain: '<S75>/Gain' */\r\n  rtb_Min = -0.5F * rtu_Valpha;\r\n\r\n  /* Gain: '<S75>/Gain1' */\r\n  rtb_Sum1_b = 0.866025388F * rtu_Vbeta;\r\n\r\n  /* Sum: '<S75>/Sum' */\r\n  rtb_Sum_i = rtb_Min + rtb_Sum1_b;\r\n\r\n  /* Sum: '<S75>/Sum1' */\r\n  rtb_Sum1_b = rtb_Min - rtb_Sum1_b;\r\n\r\n  /* Gain: '<S76>/Gain' incorporates:\r\n   *  MinMax: '<S76>/Min'\r\n   *  MinMax: '<S76>/Min1'\r\n   *  Sum: '<S76>/Sum'\r\n   */\r\n  rtb_Min = (fminf(fminf(rtu_Valpha, rtb_Sum_i), rtb_Sum1_b) + fmaxf(fmaxf\r\n              (rtu_Valpha, rtb_Sum_i), rtb_Sum1_b)) * -0.5F;\r\n\r\n  /* Sum: '<S10>/Sum' */\r\n  rty_tABC[0] = rtb_Min + rtu_Valpha;\r\n  rty_tABC[1] = rtb_Min + rtb_Sum_i;\r\n  rty_tABC[2] = rtb_Min + rtb_Sum1_b;\r\n\r\n  /* Sum: '<S10>/Sum1' incorporates:\r\n   *  Constant: '<S10>/Constant'\r\n   *  Gain: '<S10>/Gain'\r\n   *  Product: '<S10>/Divide'\r\n   */\r\n  rty_tABC[0] = -rty_tABC[0] / rtu_v_bus + 0.5F;\r\n  rty_tABC[1] = -rty_tABC[1] / rtu_v_bus + 0.5F;\r\n  rty_tABC[2] = -rty_tABC[2] / rtu_v_bus + 0.5F;\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/电流环' */\r\nvoid u(real32_T rtu_IRefD, real32_T rtu_ISensD, real32_T rtu_IRefQ, real32_T\r\n       rtu_ISensQ, real32_T *rty_PIOutputVd, real32_T *rty_PIOutputVq, DW_u\r\n       *localDW)\r\n{\r\n  real32_T rtb_DeadZone_h;\r\n  real32_T rtb_IProdOut_d;\r\n  real32_T rtb_Integrator_m;\r\n  int8_T tmp;\r\n  int8_T tmp_0;\r\n  boolean_T rtb_RelationalOperator_f;\r\n\r\n  /* Sum: '<S12>/Sum' */\r\n  rtb_Integrator_m = rtu_IRefD - rtu_ISensD;\r\n\r\n  /* Sum: '<S123>/Sum' incorporates:\r\n   *  Constant: '<S12>/Constant4'\r\n   *  DiscreteIntegrator: '<S114>/Integrator'\r\n   *  Gain: '<S12>/Gain1'\r\n   *  Product: '<S119>/PProd Out'\r\n   */\r\n  rtb_IProdOut_d = rtb_Integrator_m * 0.367728531F + localDW->Integrator_DSTATE;\r\n\r\n  /* Saturate: '<S121>/Saturation' incorporates:\r\n   *  DeadZone: '<S106>/DeadZone'\r\n   */\r\n  if (rtb_IProdOut_d > 20.0F) {\r\n    *rty_PIOutputVd = 20.0F;\r\n    rtb_IProdOut_d -= 20.0F;\r\n  } else {\r\n    if (rtb_IProdOut_d < -20.0F) {\r\n      *rty_PIOutputVd = -20.0F;\r\n    } else {\r\n      *rty_PIOutputVd = rtb_IProdOut_d;\r\n    }\r\n\r\n    if (rtb_IProdOut_d >= -20.0F) {\r\n      rtb_IProdOut_d = 0.0F;\r\n    } else {\r\n      rtb_IProdOut_d -= -20.0F;\r\n    }\r\n  }\r\n\r\n  /* End of Saturate: '<S121>/Saturation' */\r\n\r\n  /* RelationalOperator: '<S104>/Relational Operator' incorporates:\r\n   *  Constant: '<S104>/Clamping_zero'\r\n   */\r\n  rtb_RelationalOperator_f = (rtb_IProdOut_d != 0.0F);\r\n\r\n  /* Product: '<S111>/IProd Out' incorporates:\r\n   *  Constant: '<S12>/Constant3'\r\n   *  Gain: '<S12>/Gain'\r\n   */\r\n  rtb_Integrator_m *= 38.9046F;\r\n\r\n  /* Switch: '<S104>/Switch1' incorporates:\r\n   *  Constant: '<S104>/Clamping_zero'\r\n   *  Constant: '<S104>/Constant'\r\n   *  Constant: '<S104>/Constant2'\r\n   *  RelationalOperator: '<S104>/fix for DT propagation issue'\r\n   */\r\n  if (rtb_IProdOut_d > 0.0F) {\r\n    tmp = 1;\r\n  } else {\r\n    tmp = -1;\r\n  }\r\n\r\n  /* Switch: '<S104>/Switch2' incorporates:\r\n   *  Constant: '<S104>/Clamping_zero'\r\n   *  Constant: '<S104>/Constant3'\r\n   *  Constant: '<S104>/Constant4'\r\n   *  RelationalOperator: '<S104>/fix for DT propagation issue1'\r\n   */\r\n  if (rtb_Integrator_m > 0.0F) {\r\n    tmp_0 = 1;\r\n  } else {\r\n    tmp_0 = -1;\r\n  }\r\n\r\n  /* Sum: '<S12>/Sum1' */\r\n  rtb_IProdOut_d = rtu_IRefQ - rtu_ISensQ;\r\n\r\n  /* Sum: '<S175>/Sum' incorporates:\r\n   *  Constant: '<S12>/Constant2'\r\n   *  DiscreteIntegrator: '<S166>/Integrator'\r\n   *  Gain: '<S12>/Gain2'\r\n   *  Product: '<S171>/PProd Out'\r\n   */\r\n  rtb_DeadZone_h = rtb_IProdOut_d * 0.367728531F + localDW->Integrator_DSTATE_c;\r\n\r\n  /* Saturate: '<S173>/Saturation' incorporates:\r\n   *  DeadZone: '<S158>/DeadZone'\r\n   */\r\n  if (rtb_DeadZone_h > 20.0F) {\r\n    *rty_PIOutputVq = 20.0F;\r\n    rtb_DeadZone_h -= 20.0F;\r\n  } else {\r\n    if (rtb_DeadZone_h < -20.0F) {\r\n      *rty_PIOutputVq = -20.0F;\r\n    } else {\r\n      *rty_PIOutputVq = rtb_DeadZone_h;\r\n    }\r\n\r\n    if (rtb_DeadZone_h >= -20.0F) {\r\n      rtb_DeadZone_h = 0.0F;\r\n    } else {\r\n      rtb_DeadZone_h -= -20.0F;\r\n    }\r\n  }\r\n\r\n  /* End of Saturate: '<S173>/Saturation' */\r\n\r\n  /* Product: '<S163>/IProd Out' incorporates:\r\n   *  Constant: '<S12>/Constant1'\r\n   *  Gain: '<S12>/Gain3'\r\n   */\r\n  rtb_IProdOut_d *= 38.9046F;\r\n\r\n  /* Switch: '<S104>/Switch' incorporates:\r\n   *  Constant: '<S104>/Constant1'\r\n   *  Logic: '<S104>/AND3'\r\n   *  RelationalOperator: '<S104>/Equal1'\r\n   *  Switch: '<S104>/Switch1'\r\n   *  Switch: '<S104>/Switch2'\r\n   */\r\n  if (rtb_RelationalOperator_f && (tmp == tmp_0)) {\r\n    rtb_Integrator_m = 0.0F;\r\n  }\r\n\r\n  /* Update for DiscreteIntegrator: '<S114>/Integrator' incorporates:\r\n   *  Switch: '<S104>/Switch'\r\n   */\r\n  localDW->Integrator_DSTATE += 0.0001F * rtb_Integrator_m;\r\n\r\n  /* Switch: '<S156>/Switch1' incorporates:\r\n   *  Constant: '<S156>/Clamping_zero'\r\n   *  Constant: '<S156>/Constant'\r\n   *  Constant: '<S156>/Constant2'\r\n   *  RelationalOperator: '<S156>/fix for DT propagation issue'\r\n   */\r\n  if (rtb_DeadZone_h > 0.0F) {\r\n    tmp = 1;\r\n  } else {\r\n    tmp = -1;\r\n  }\r\n\r\n  /* Switch: '<S156>/Switch2' incorporates:\r\n   *  Constant: '<S156>/Clamping_zero'\r\n   *  Constant: '<S156>/Constant3'\r\n   *  Constant: '<S156>/Constant4'\r\n   *  RelationalOperator: '<S156>/fix for DT propagation issue1'\r\n   */\r\n  if (rtb_IProdOut_d > 0.0F) {\r\n    tmp_0 = 1;\r\n  } else {\r\n    tmp_0 = -1;\r\n  }\r\n\r\n  /* Switch: '<S156>/Switch' incorporates:\r\n   *  Constant: '<S156>/Clamping_zero'\r\n   *  Constant: '<S156>/Constant1'\r\n   *  Logic: '<S156>/AND3'\r\n   *  RelationalOperator: '<S156>/Equal1'\r\n   *  RelationalOperator: '<S156>/Relational Operator'\r\n   *  Switch: '<S156>/Switch1'\r\n   *  Switch: '<S156>/Switch2'\r\n   */\r\n  if ((rtb_DeadZone_h != 0.0F) && (tmp == tmp_0)) {\r\n    rtb_IProdOut_d = 0.0F;\r\n  }\r\n\r\n  /* Update for DiscreteIntegrator: '<S166>/Integrator' incorporates:\r\n   *  Switch: '<S156>/Switch'\r\n   */\r\n  localDW->Integrator_DSTATE_c += 0.0001F * rtb_IProdOut_d;\r\n}\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (rtIsInf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > floor(u1))) {\r\n      real_T q;\r\n      q = fabs(u0 / u1);\r\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid Flux_Nonsensor_step(void)\r\n{\r\n  real_T rtb_Add_i;\r\n  real_T rtb_Add_l;\r\n  real_T rtb_Add_lj;\r\n  real_T rtb_DiscreteTimeIntegrator3;\r\n  real_T rtb_DiscreteTimeIntegrator3_c;\r\n  real_T rtb_DiscreteTimeIntegrator_h;\r\n  real_T rtb_Divide;\r\n  real_T rtb_Gain4;\r\n  real_T rtb_Merge;\r\n  real_T rtb_PolePairs;\r\n  real_T rtb_VectorConcatenate_idx_1;\r\n  real_T rtb_sine_cosine_o1;\r\n  real_T u0;\r\n  real32_T rtb_Gain5[3];\r\n  real32_T rtb_TmpSignalConversionAtInvParkInport3_tmp[2];\r\n  real32_T rtb_DeadZone;\r\n  real32_T rtb_Gain2_o;\r\n  real32_T rtb_Gain_p;\r\n  real32_T rtb_IProdOut;\r\n  real32_T rtb_Integrator;\r\n  real32_T rtb_Saturation;\r\n  int8_T tmp;\r\n  int8_T tmp_0;\r\n\r\n  /* RateTransition: '<Root>/Rate Transition1' */\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* DiscreteIntegrator: '<S203>/Discrete-Time Integrator3' */\r\n    if (rtDW.DiscreteTimeIntegrator3_IC_LOADING != 0) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE = 0.0;\r\n    }\r\n\r\n    rtb_DiscreteTimeIntegrator3 = rtDW.DiscreteTimeIntegrator3_DSTATE;\r\n\r\n    /* Switch: '<S188>/Switch1' incorporates:\r\n     *  Constant: '<S188>/Constant1'\r\n     *  Constant: '<S190>/Constant'\r\n     *  RelationalOperator: '<S190>/Compare'\r\n     *  Sum: '<S188>/Add1'\r\n     *  UnitDelay: '<S188>/Unit Delay'\r\n     */\r\n    if (rtDW.UnitDelay_DSTATE >= -3.1415926535897931) {\r\n      /* Switch: '<S188>/Switch' incorporates:\r\n       *  Constant: '<S188>/Constant3'\r\n       *  Constant: '<S189>/Constant'\r\n       *  RelationalOperator: '<S189>/Compare'\r\n       *  Sum: '<S188>/Subtract'\r\n       */\r\n      if (rtDW.UnitDelay_DSTATE <= 3.1415926535897931) {\r\n        rtb_PolePairs = rtDW.UnitDelay_DSTATE;\r\n      } else {\r\n        rtb_PolePairs = rtDW.UnitDelay_DSTATE - 6.2831854820251465;\r\n      }\r\n\r\n      /* End of Switch: '<S188>/Switch' */\r\n    } else {\r\n      rtb_PolePairs = rtDW.UnitDelay_DSTATE + 6.2831854820251465;\r\n    }\r\n\r\n    /* End of Switch: '<S188>/Switch1' */\r\n\r\n    /* Gain: '<S185>/Gain4' */\r\n    rtb_Gain4 = 3.0 * rtb_PolePairs;\r\n\r\n    /* Trigonometry: '<S187>/sine_cosine' */\r\n    rtb_sine_cosine_o1 = sin(rtb_Gain4);\r\n    rtb_Gain4 = cos(rtb_Gain4);\r\n\r\n    /* DiscreteIntegrator: '<S204>/Discrete-Time Integrator3' */\r\n    if (rtDW.DiscreteTimeIntegrator3_IC_LOADING_m != 0) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE_j = 0.0;\r\n    }\r\n\r\n    rtb_DiscreteTimeIntegrator3_c = rtDW.DiscreteTimeIntegrator3_DSTATE_j;\r\n\r\n    /* Sum: '<S198>/Add1' incorporates:\r\n     *  DiscreteIntegrator: '<S203>/Discrete-Time Integrator3'\r\n     *  DiscreteIntegrator: '<S204>/Discrete-Time Integrator3'\r\n     *  Product: '<S198>/Product2'\r\n     *  Product: '<S198>/Product3'\r\n     */\r\n    rtb_DiscreteTimeIntegrator_h = rtDW.DiscreteTimeIntegrator3_DSTATE *\r\n      rtb_Gain4 - rtDW.DiscreteTimeIntegrator3_DSTATE_j * rtb_sine_cosine_o1;\r\n\r\n    /* Sum: '<S198>/Add' incorporates:\r\n     *  DiscreteIntegrator: '<S203>/Discrete-Time Integrator3'\r\n     *  DiscreteIntegrator: '<S204>/Discrete-Time Integrator3'\r\n     *  Product: '<S198>/Product'\r\n     *  Product: '<S198>/Product1'\r\n     */\r\n    rtb_Add_i = rtDW.DiscreteTimeIntegrator3_DSTATE * rtb_sine_cosine_o1 +\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE_j * rtb_Gain4;\r\n\r\n    /* Sum: '<S197>/Subtract1' incorporates:\r\n     *  Gain: '<S197>/Gain2'\r\n     *  Gain: '<S197>/Gain3'\r\n     */\r\n    rtb_VectorConcatenate_idx_1 = -0.5 * rtb_DiscreteTimeIntegrator_h +\r\n      0.8660254037844386 * rtb_Add_i;\r\n\r\n    /* Sum: '<S197>/Subtract2' incorporates:\r\n     *  Gain: '<S197>/Gain1'\r\n     *  Gain: '<S197>/Gain4'\r\n     */\r\n    rtb_Add_i = -0.5 * rtb_DiscreteTimeIntegrator_h + -0.8660254037844386 *\r\n      rtb_Add_i;\r\n\r\n    /* RateTransition: '<Root>/Rate Transition' incorporates:\r\n     *  SignalConversion generated from: '<S184>/Vector Concatenate'\r\n     */\r\n    if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n      rtDW.RateTransition_Buffer = rtb_DiscreteTimeIntegrator_h;\r\n    }\r\n\r\n    if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n      rtDW.RateTransition1_Buffer = rtb_VectorConcatenate_idx_1;\r\n    }\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition' */\r\n  if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion' */\r\n    Phase_CurrentA = (real32_T)rtDW.RateTransition_Buffer;\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition2' */\r\n  if ((rtM->Timing.TaskCounters.TID[1] == 0) && (rtM->Timing.TaskCounters.TID[2]\r\n       == 0)) {\r\n    rtDW.RateTransition2_Buffer = rtb_Add_i;\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition1' */\r\n  if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion1' */\r\n    Phase_CurrentB = (real32_T)rtDW.RateTransition1_Buffer;\r\n  }\r\n\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion6' incorporates:\r\n     *  Constant: '<Root>/speed-target'\r\n     */\r\n    Speed_target = 1000.0F;\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition2' incorporates:\r\n   *  Memory: '<S2>/Memory'\r\n   *  SignalConversion generated from: '<S2>/InvPark'\r\n   */\r\n  if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion2' */\r\n    Phase_CurrentC = (real32_T)rtDW.RateTransition2_Buffer;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion4' incorporates:\r\n     *  Constant: '<Root>/Constant1'\r\n     */\r\n    Bus_voltage = 30.0F;\r\n\r\n    /* Outputs for Atomic SubSystem: '<Root>/FOC电机控制' */\r\n\r\n    /* user code (Output function Body) */\r\n\r\n    /* System '<Root>/FOC电机控制' */\r\n    Phase_CurrentA= Ia_A;\r\n    Phase_CurrentB= Ib_A;\r\n    Phase_CurrentC = Ic_A;\r\n    Bus_voltage = Bus_volt_V;\r\n    speed= motor_rotate_speed_rpm_resolver;\r\n    Speed_target = motor_rpm_ref;\r\n\r\n    /* UnitDelay: '<S18>/Unit Delay' */\r\n    ObserverTheta = rtDW.UnitDelay_DSTATE_b;\r\n\r\n    /* SignalConversion generated from: '<S2>/InvPark' incorporates:\r\n     *  SignalConversion generated from: '<S2>/Park'\r\n     *  Trigonometry: '<S2>/Sin'\r\n     *  Trigonometry: '<S2>/Sin1'\r\n     */\r\n    rtb_TmpSignalConversionAtInvParkInport3_tmp[0] = sinf(ObserverTheta);\r\n    rtb_TmpSignalConversionAtInvParkInport3_tmp[1] = cosf(ObserverTheta);\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/Clark' */\r\n    /* Gain: '<S6>/Gain' incorporates:\r\n     *  Gain: '<S6>/Gain1'\r\n     *  Sum: '<S6>/Sum'\r\n     *  Sum: '<S6>/Sum1'\r\n     */\r\n    rtb_Gain_p = (Phase_CurrentA - (Phase_CurrentB + Phase_CurrentC) * 0.5F) *\r\n      0.666666687F;\r\n\r\n    /* Gain: '<S6>/Gain2' incorporates:\r\n     *  Sum: '<S6>/Sum2'\r\n     */\r\n    rtb_Gain2_o = (Phase_CurrentB - Phase_CurrentC) * 0.577350259F;\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/Clark' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/Park' */\r\n    /* SignalConversion generated from: '<S2>/Park' */\r\n    Park(rtb_Gain_p, rtb_Gain2_o, rtb_TmpSignalConversionAtInvParkInport3_tmp,\r\n         &Id_measured, &Iq_measured);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/Park' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/speed_control' */\r\n    rtb_DeadZone = speed_control(rtDW.Memory_PreviousInput);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/speed_control' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/电流环' */\r\n    /* SignalConversion generated from: '<S2>/电流环' incorporates:\r\n     *  Constant: '<S2>/Constant'\r\n     *  Memory: '<S2>/Memory'\r\n     */\r\n    u(0.0F, Id_measured, rtb_DeadZone, Iq_measured, &Vd_voltage, &Vq_voltage,\r\n      &rtDW.u_j);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/电流环' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/InvPark' */\r\n    InvPark(Vd_voltage, Vq_voltage, rtb_TmpSignalConversionAtInvParkInport3_tmp,\r\n            &rtb_DeadZone, &rtb_Saturation);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/InvPark' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/SVPWM1' */\r\n    SVPWM1(rtb_DeadZone, rtb_Saturation, Bus_voltage, rtb_Gain5);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/SVPWM1' */\r\n\r\n    /* Saturate: '<S2>/Saturation4' incorporates:\r\n     *  Gain: '<S2>/Gain5'\r\n     *  SignalConversion generated from: '<S2>/InvPark'\r\n     */\r\n    rtb_IProdOut = 12500.0F * rtb_Gain5[0];\r\n    if (rtb_IProdOut > 12500.0F) {\r\n      rtb_Gain5[0] = 12500.0F;\r\n    } else if (rtb_IProdOut < 0.0F) {\r\n      rtb_Gain5[0] = 0.0F;\r\n    } else {\r\n      rtb_Gain5[0] = rtb_IProdOut;\r\n    }\r\n\r\n    rtb_IProdOut = 12500.0F * rtb_Gain5[1];\r\n    if (rtb_IProdOut > 12500.0F) {\r\n      rtb_Gain5[1] = 12500.0F;\r\n    } else if (rtb_IProdOut < 0.0F) {\r\n      rtb_Gain5[1] = 0.0F;\r\n    } else {\r\n      rtb_Gain5[1] = rtb_IProdOut;\r\n    }\r\n\r\n    rtb_IProdOut = 12500.0F * rtb_Gain5[2];\r\n    if (rtb_IProdOut > 12500.0F) {\r\n      rtb_Gain5[2] = 12500.0F;\r\n    } else if (rtb_IProdOut < 0.0F) {\r\n      rtb_Gain5[2] = 0.0F;\r\n    } else {\r\n      rtb_Gain5[2] = rtb_IProdOut;\r\n    }\r\n\r\n    /* End of Saturate: '<S2>/Saturation4' */\r\n\r\n    /* Sum: '<S14>/Sum' incorporates:\r\n     *  DiscreteIntegrator: '<S14>/Integrator'\r\n     *  Gain: '<S14>/Gain2'\r\n     */\r\n    rtb_IProdOut = rtDW.Integrator_DSTATE - 0.0001F * rtb_Gain_p;\r\n\r\n    /* Sum: '<S14>/Sum1' incorporates:\r\n     *  DiscreteIntegrator: '<S14>/Integrator1'\r\n     *  Gain: '<S14>/Gain3'\r\n     */\r\n    rtb_Integrator = rtDW.Integrator1_DSTATE - 0.000104F * rtb_Gain2_o;\r\n\r\n    /* Sum: '<S14>/Add2' incorporates:\r\n     *  Constant: '<S14>/Constant'\r\n     *  Math: '<S14>/Math Function'\r\n     *  Math: '<S14>/Math Function1'\r\n     *  Math: '<S14>/Math Function2'\r\n     *\r\n     * About '<S14>/Math Function':\r\n     *  Operator: magnitude^2\r\n     *\r\n     * About '<S14>/Math Function1':\r\n     *  Operator: magnitude^2\r\n     *\r\n     * About '<S14>/Math Function2':\r\n     *  Operator: magnitude^2\r\n     */\r\n    err = (0.000337456935F - rtb_IProdOut * rtb_IProdOut) - rtb_Integrator *\r\n      rtb_Integrator;\r\n\r\n    /* Sum: '<S14>/Add' incorporates:\r\n     *  Constant: '<S14>/Constant3'\r\n     *  Gain: '<S14>/Gain'\r\n     *  Product: '<S14>/Product'\r\n     *  Product: '<S14>/Product2'\r\n     *  Sum: '<S14>/Add4'\r\n     */\r\n    rtb_Gain_p = (rtb_DeadZone - 0.02065F * rtb_Gain_p) + rtb_IProdOut * err *\r\n      Gamma;\r\n\r\n    /* Sum: '<S14>/Add1' incorporates:\r\n     *  Constant: '<S14>/Constant3'\r\n     *  Gain: '<S14>/Gain1'\r\n     *  Product: '<S14>/Product1'\r\n     *  Product: '<S14>/Product3'\r\n     *  Sum: '<S14>/Add5'\r\n     */\r\n    rtb_Gain2_o = err * rtb_Integrator * Gamma + (rtb_Saturation - 0.02065F *\r\n      rtb_Gain2_o);\r\n\r\n    /* Outputs for Atomic SubSystem: '<S15>/Sine_Cosine' */\r\n    Sine_Cosine();\r\n\r\n    /* End of Outputs for SubSystem: '<S15>/Sine_Cosine' */\r\n\r\n    /* Sum: '<S15>/Sum' incorporates:\r\n     *  Product: '<S15>/Product'\r\n     *  Product: '<S15>/Product1'\r\n     */\r\n    rtb_IProdOut = rtb_Integrator * rtDW.Cos1 - rtDW.Sin1 * rtb_IProdOut;\r\n\r\n    /* Sum: '<S63>/Sum' incorporates:\r\n     *  Constant: '<S15>/Constant2'\r\n     *  DiscreteIntegrator: '<S54>/Integrator'\r\n     *  Product: '<S59>/PProd Out'\r\n     */\r\n    rtb_Saturation = rtb_IProdOut * pll_omega + rtDW.Integrator_DSTATE_a;\r\n\r\n    /* DeadZone: '<S46>/DeadZone' */\r\n    if (rtb_Saturation > 942.477783F) {\r\n      rtb_DeadZone = rtb_Saturation - 942.477783F;\r\n    } else if (rtb_Saturation >= -942.477783F) {\r\n      rtb_DeadZone = 0.0F;\r\n    } else {\r\n      rtb_DeadZone = rtb_Saturation - -942.477783F;\r\n    }\r\n\r\n    /* End of DeadZone: '<S46>/DeadZone' */\r\n\r\n    /* Product: '<S51>/IProd Out' incorporates:\r\n     *  Constant: '<S15>/Constant3'\r\n     */\r\n    rtb_IProdOut *= pll_xi;\r\n\r\n    /* Switch: '<S44>/Switch1' incorporates:\r\n     *  Constant: '<S44>/Clamping_zero'\r\n     *  Constant: '<S44>/Constant'\r\n     *  Constant: '<S44>/Constant2'\r\n     *  RelationalOperator: '<S44>/fix for DT propagation issue'\r\n     */\r\n    if (rtb_DeadZone > 0.0F) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    /* Switch: '<S44>/Switch2' incorporates:\r\n     *  Constant: '<S44>/Clamping_zero'\r\n     *  Constant: '<S44>/Constant3'\r\n     *  Constant: '<S44>/Constant4'\r\n     *  RelationalOperator: '<S44>/fix for DT propagation issue1'\r\n     */\r\n    if (rtb_IProdOut > 0.0F) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    /* Switch: '<S44>/Switch' incorporates:\r\n     *  Constant: '<S44>/Clamping_zero'\r\n     *  Constant: '<S44>/Constant1'\r\n     *  Logic: '<S44>/AND3'\r\n     *  RelationalOperator: '<S44>/Equal1'\r\n     *  RelationalOperator: '<S44>/Relational Operator'\r\n     *  Switch: '<S44>/Switch1'\r\n     *  Switch: '<S44>/Switch2'\r\n     */\r\n    if ((rtb_DeadZone != 0.0F) && (tmp == tmp_0)) {\r\n      rtb_DeadZone = 0.0F;\r\n    } else {\r\n      rtb_DeadZone = rtb_IProdOut;\r\n    }\r\n\r\n    /* End of Switch: '<S44>/Switch' */\r\n\r\n    /* Saturate: '<S61>/Saturation' */\r\n    if (rtb_Saturation > 942.477783F) {\r\n      rtb_Saturation = 942.477783F;\r\n    } else if (rtb_Saturation < -942.477783F) {\r\n      rtb_Saturation = -942.477783F;\r\n    }\r\n\r\n    /* End of Saturate: '<S61>/Saturation' */\r\n\r\n    /* Sum: '<S18>/Sum1' incorporates:\r\n     *  Gain: '<S18>/Ts'\r\n     */\r\n    rtb_IProdOut = 0.0001F * rtb_Saturation + ObserverTheta;\r\n\r\n    /* If: '<S71>/If1' */\r\n    if (rtb_IProdOut > 6.28318548F) {\r\n      /* Outputs for IfAction SubSystem: '<S71>/If Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S73>/Action Port'\r\n       */\r\n      /* Sum: '<S73>/Subtract1' incorporates:\r\n       *  Constant: '<S73>/2pi'\r\n       */\r\n      rtb_IProdOut -= 6.28318548F;\r\n\r\n      /* End of Outputs for SubSystem: '<S71>/If Action Subsystem2' */\r\n    } else if (rtb_IProdOut < 0.0F) {\r\n      /* Outputs for IfAction SubSystem: '<S71>/If Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S74>/Action Port'\r\n       */\r\n      /* Sum: '<S74>/Subtract1' incorporates:\r\n       *  Constant: '<S74>/Angle_offset'\r\n       */\r\n      rtb_IProdOut += 6.28318548F;\r\n\r\n      /* End of Outputs for SubSystem: '<S71>/If Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S71>/If1' */\r\n\r\n    /* Gain: '<S2>/Gain' */\r\n    rtb_Saturation *= 3.18309879F;\r\n\r\n    /* user code (Update function Body) */\r\n\r\n    /* System '<Root>/FOC电机控制' */\r\n    __HAL_TIM_SetCompare(&htim1,TIM_CHANNEL_1,12500-Ta);\r\n    __HAL_TIM_SetCompare(&htim1,TIM_CHANNEL_2,12500-Tb);\r\n    __HAL_TIM_SetCompare(&htim1,TIM_CHANNEL_3,12500-Tc);\r\n\r\n    /* Update for UnitDelay: '<S18>/Unit Delay' */\r\n    rtDW.UnitDelay_DSTATE_b = rtb_IProdOut;\r\n\r\n    /* Update for Memory: '<S2>/Memory' */\r\n    rtDW.Memory_PreviousInput = rtb_Saturation;\r\n\r\n    /* Update for DiscreteIntegrator: '<S14>/Integrator' */\r\n    rtDW.Integrator_DSTATE += 0.0001F * rtb_Gain_p;\r\n\r\n    /* Update for DiscreteIntegrator: '<S14>/Integrator1' */\r\n    rtDW.Integrator1_DSTATE += 0.0001F * rtb_Gain2_o;\r\n\r\n    /* Update for DiscreteIntegrator: '<S54>/Integrator' */\r\n    rtDW.Integrator_DSTATE_a += 0.0001F * rtb_DeadZone;\r\n\r\n    /* End of Outputs for SubSystem: '<Root>/FOC电机控制' */\r\n\r\n    /* Sum: '<S5>/Sum1' incorporates:\r\n     *  Constant: '<S5>/Constant'\r\n     *  Gain: '<S5>/Gain'\r\n     *  Gain: '<S5>/Gain1'\r\n     *  Sum: '<S5>/Sum'\r\n     */\r\n    rtb_VectorConcatenate_idx_1 = -(8.0E-5F * rtb_Gain5[0] - 0.5) + 0.5;\r\n    rtb_DiscreteTimeIntegrator_h = -(8.0E-5F * rtb_Gain5[1] - 0.5) + 0.5;\r\n    u0 = -(8.0E-5F * rtb_Gain5[2] - 0.5) + 0.5;\r\n\r\n    /* Gain: '<S1>/Gain' incorporates:\r\n     *  Saturate: '<S1>/Saturation2'\r\n     *  Sum: '<S1>/Sum'\r\n     */\r\n    rtb_Add_i = ((rtb_DiscreteTimeIntegrator_h + u0) +\r\n                 rtb_VectorConcatenate_idx_1) * 0.33333333333333331;\r\n\r\n    /* Product: '<S1>/Product' incorporates:\r\n     *  Constant: '<Root>/Constant1'\r\n     *  Saturate: '<S1>/Saturation2'\r\n     *  Sum: '<S1>/Sum1'\r\n     *  Sum: '<S1>/Sum2'\r\n     *  Sum: '<S1>/Sum3'\r\n     *  Switch: '<S1>/Switch'\r\n     */\r\n    rtDW.Product[0] = (rtb_VectorConcatenate_idx_1 - rtb_Add_i) * 30.0;\r\n    rtDW.Product[1] = (rtb_DiscreteTimeIntegrator_h - rtb_Add_i) * 30.0;\r\n    rtDW.Product[2] = (u0 - rtb_Add_i) * 30.0;\r\n  }\r\n\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Sum: '<S196>/Add' incorporates:\r\n     *  Gain: '<S196>/Gain'\r\n     *  Gain: '<S196>/Gain1'\r\n     *  Gain: '<S196>/Gain4'\r\n     */\r\n    rtb_Add_i = (0.66666666666666663 * rtDW.Product[0] + -0.33333333333333331 *\r\n                 rtDW.Product[1]) + -0.33333333333333331 * rtDW.Product[2];\r\n\r\n    /* Sum: '<S196>/Add1' incorporates:\r\n     *  Gain: '<S196>/Gain2'\r\n     *  Gain: '<S196>/Gain3'\r\n     */\r\n    rtb_Merge = 0.57735026918962573 * rtDW.Product[1] + -0.57735026918962573 *\r\n      rtDW.Product[2];\r\n\r\n    /* Gain: '<S185>/Gain' incorporates:\r\n     *  DiscreteIntegrator: '<S185>/Discrete-Time Integrator'\r\n     */\r\n    rtb_VectorConcatenate_idx_1 = 3.0 * rtDW.DiscreteTimeIntegrator_DSTATE;\r\n\r\n    /* Sum: '<S204>/Add' incorporates:\r\n     *  Constant: '<S210>/Constant'\r\n     *  Constant: '<S211>/Constant'\r\n     *  Product: '<S201>/Product'\r\n     *  Product: '<S201>/Product1'\r\n     *  Product: '<S204>/Product'\r\n     *  Product: '<S208>/Product'\r\n     *  Product: '<S209>/Product'\r\n     *  Product: '<S210>/Product'\r\n     *  Product: '<S211>/Product'\r\n     *  Sum: '<S201>/Add'\r\n     */\r\n    rtb_Add_lj = (((rtb_Merge * rtb_Gain4 - rtb_Add_i * rtb_sine_cosine_o1) /\r\n                   0.000104 - rtb_DiscreteTimeIntegrator3 *\r\n                   rtb_VectorConcatenate_idx_1 * 0.0001 / 0.000104) -\r\n                  rtb_VectorConcatenate_idx_1 * 0.01837 / 0.000104) -\r\n      rtb_DiscreteTimeIntegrator3_c * 0.02065 / 0.000104;\r\n\r\n    /* Sum: '<S203>/Add' incorporates:\r\n     *  Constant: '<S207>/Constant'\r\n     *  Product: '<S201>/Product2'\r\n     *  Product: '<S201>/Product3'\r\n     *  Product: '<S203>/Product'\r\n     *  Product: '<S205>/Product'\r\n     *  Product: '<S206>/Product'\r\n     *  Product: '<S207>/Product'\r\n     *  Sum: '<S201>/Add1'\r\n     */\r\n    rtb_Merge = ((rtb_Add_i * rtb_Gain4 + rtb_Merge * rtb_sine_cosine_o1) /\r\n                 0.0001 + rtb_VectorConcatenate_idx_1 *\r\n                 rtb_DiscreteTimeIntegrator3_c * 0.000104 / 0.0001) -\r\n      rtb_DiscreteTimeIntegrator3 * 0.02065 / 0.0001;\r\n\r\n    /* RateTransition: '<Root>/Rate Transition8' incorporates:\r\n     *  DiscreteIntegrator: '<S185>/Discrete-Time Integrator'\r\n     *  Gain: '<Root>/Gain'\r\n     */\r\n    if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n      rtDW.RateTransition8_Buffer = 9.5492965855137211 *\r\n        rtDW.DiscreteTimeIntegrator_DSTATE;\r\n    }\r\n\r\n    /* Signum: '<S185>/Sign' incorporates:\r\n     *  DiscreteIntegrator: '<S185>/Discrete-Time Integrator'\r\n     */\r\n    if (rtIsNaN(rtDW.DiscreteTimeIntegrator_DSTATE)) {\r\n      rtb_Gain4 = (rtNaN);\r\n    } else if (rtDW.DiscreteTimeIntegrator_DSTATE < 0.0) {\r\n      rtb_Gain4 = -1.0;\r\n    } else {\r\n      rtb_Gain4 = (rtDW.DiscreteTimeIntegrator_DSTATE > 0.0);\r\n    }\r\n\r\n    /* Product: '<S185>/Divide' incorporates:\r\n     *  DiscreteIntegrator: '<S185>/Discrete-Time Integrator'\r\n     *  Gain: '<Root>/Gain1'\r\n     *  Gain: '<S199>/Gain1'\r\n     *  Gain: '<S199>/Gain2'\r\n     *  Product: '<S185>/Divide1'\r\n     *  Product: '<S185>/Divide2'\r\n     *  Product: '<S199>/Product'\r\n     *  Product: '<S202>/Product'\r\n     *  Signum: '<S185>/Sign'\r\n     *  Sum: '<S185>/Sum1'\r\n     *  Sum: '<S199>/Add'\r\n     */\r\n    rtb_Divide = ((((rtb_DiscreteTimeIntegrator3 * rtb_DiscreteTimeIntegrator3_c\r\n                     * -3.9999999999999888E-6 + 0.01837 *\r\n                     rtb_DiscreteTimeIntegrator3_c) * 4.5 - 0.002 *\r\n                    rtDW.DiscreteTimeIntegrator_DSTATE) -\r\n                   rtDW.DiscreteTimeIntegrator_DSTATE * 8.0E-5) - 0.0 *\r\n                  rtb_Gain4) / 0.000258;\r\n\r\n    /* Sum: '<S188>/Add' incorporates:\r\n     *  DiscreteIntegrator: '<S185>/Discrete-Time Integrator'\r\n     *  Gain: '<S188>/Gain1'\r\n     */\r\n    rtb_Add_l = 2.5E-5 * rtDW.DiscreteTimeIntegrator_DSTATE + rtb_PolePairs;\r\n\r\n    /* RateTransition: '<Root>/Rate Transition3' incorporates:\r\n     *  Constant: '<Root>/Constant3  '\r\n     *  Gain: '<Root>/PolePairs'\r\n     *  Math: '<Root>/Mod'\r\n     */\r\n    if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n      rtDW.RateTransition3_Buffer = rt_modd_snf(3.0 * rtb_PolePairs,\r\n        6.2831853071795862);\r\n    }\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition8' incorporates:\r\n   *  RateTransition: '<Root>/Rate Transition3'\r\n   */\r\n  if (rtM->Timing.TaskCounters.TID[2] == 0) {\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion5' */\r\n    speed = (real32_T)rtDW.RateTransition8_Buffer;\r\n\r\n    /* DataTypeConversion: '<Root>/Data Type Conversion3' */\r\n    Theta = (real32_T)rtDW.RateTransition3_Buffer;\r\n  }\r\n\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Update for DiscreteIntegrator: '<S203>/Discrete-Time Integrator3' */\r\n    rtDW.DiscreteTimeIntegrator3_IC_LOADING = 0U;\r\n    rtDW.DiscreteTimeIntegrator3_DSTATE += 2.5E-5 * rtb_Merge;\r\n    if (rtDW.DiscreteTimeIntegrator3_DSTATE > 1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE = 1.0E+7;\r\n    } else if (rtDW.DiscreteTimeIntegrator3_DSTATE < -1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE = -1.0E+7;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: '<S203>/Discrete-Time Integrator3' */\r\n\r\n    /* Update for UnitDelay: '<S188>/Unit Delay' */\r\n    rtDW.UnitDelay_DSTATE = rtb_Add_l;\r\n\r\n    /* Update for DiscreteIntegrator: '<S204>/Discrete-Time Integrator3' */\r\n    rtDW.DiscreteTimeIntegrator3_IC_LOADING_m = 0U;\r\n    rtDW.DiscreteTimeIntegrator3_DSTATE_j += 2.5E-5 * rtb_Add_lj;\r\n    if (rtDW.DiscreteTimeIntegrator3_DSTATE_j > 1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE_j = 1.0E+7;\r\n    } else if (rtDW.DiscreteTimeIntegrator3_DSTATE_j < -1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator3_DSTATE_j = -1.0E+7;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: '<S204>/Discrete-Time Integrator3' */\r\n\r\n    /* Update for DiscreteIntegrator: '<S185>/Discrete-Time Integrator' */\r\n    rtDW.DiscreteTimeIntegrator_DSTATE += 2.5E-5 * rtb_Divide;\r\n    if (rtDW.DiscreteTimeIntegrator_DSTATE > 1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator_DSTATE = 1.0E+7;\r\n    } else if (rtDW.DiscreteTimeIntegrator_DSTATE < -1.0E+7) {\r\n      rtDW.DiscreteTimeIntegrator_DSTATE = -1.0E+7;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: '<S185>/Discrete-Time Integrator' */\r\n  }\r\n\r\n  rate_scheduler();\r\n}\r\n\r\n/* Model initialize function */\r\nvoid Flux_Nonsensor_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S203>/Discrete-Time Integrator3' */\r\n  rtDW.DiscreteTimeIntegrator3_IC_LOADING = 1U;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S204>/Discrete-Time Integrator3' */\r\n  rtDW.DiscreteTimeIntegrator3_IC_LOADING_m = 1U;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Flux_Nonsensor.h","type":"header","group":"model","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * File: Flux_Nonsensor.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef Flux_Nonsensor_h_\r\n#define Flux_Nonsensor_h_\r\n#ifndef Flux_Nonsensor_COMMON_INCLUDES_\r\n#define Flux_Nonsensor_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* Flux_Nonsensor_COMMON_INCLUDES_ */\r\n\r\n#include \"Flux_Nonsensor_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n\r\n/* Includes for objects with custom storage classes */\r\n#include \"global_mcu_adc_isr.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* user code (top of header file) */\r\n/* System '<Root>/FOC电机控制' */\r\n#include \"main.h\"\r\n\r\n/* Block signals and states (default storage) for system '<S2>/电流环' */\r\ntypedef struct {\r\n  real32_T Integrator_DSTATE;          /* '<S114>/Integrator' */\r\n  real32_T Integrator_DSTATE_c;        /* '<S166>/Integrator' */\r\n} DW_u;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  DW_u u_j;                            /* '<S2>/电流环' */\r\n  real_T Product[3];                   /* '<S1>/Product' */\r\n  real_T DiscreteTimeIntegrator3_DSTATE;/* '<S203>/Discrete-Time Integrator3' */\r\n  real_T UnitDelay_DSTATE;             /* '<S188>/Unit Delay' */\r\n  real_T DiscreteTimeIntegrator3_DSTATE_j;/* '<S204>/Discrete-Time Integrator3' */\r\n  real_T DiscreteTimeIntegrator_DSTATE;/* '<S185>/Discrete-Time Integrator' */\r\n  real_T RateTransition_Buffer;        /* '<Root>/Rate Transition' */\r\n  real_T RateTransition1_Buffer;       /* '<Root>/Rate Transition1' */\r\n  real_T RateTransition2_Buffer;       /* '<Root>/Rate Transition2' */\r\n  real_T RateTransition8_Buffer;       /* '<Root>/Rate Transition8' */\r\n  real_T RateTransition3_Buffer;       /* '<Root>/Rate Transition3' */\r\n  real32_T Cos1;                       /* '<S17>/Cos1' */\r\n  real32_T Sin1;                       /* '<S17>/Sin1' */\r\n  real32_T UnitDelay_DSTATE_b;         /* '<S18>/Unit Delay' */\r\n  real32_T Integrator_DSTATE;          /* '<S14>/Integrator' */\r\n  real32_T Integrator1_DSTATE;         /* '<S14>/Integrator1' */\r\n  real32_T Integrator_DSTATE_a;        /* '<S54>/Integrator' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE_k;/* '<S11>/Discrete-Time Integrator' */\r\n  real32_T Memory_PreviousInput;       /* '<S2>/Memory' */\r\n  int8_T DiscreteTimeIntegrator_PrevResetState;/* '<S11>/Discrete-Time Integrator' */\r\n  uint8_T DiscreteTimeIntegrator3_IC_LOADING;/* '<S203>/Discrete-Time Integrator3' */\r\n  uint8_T DiscreteTimeIntegrator3_IC_LOADING_m;/* '<S204>/Discrete-Time Integrator3' */\r\n  boolean_T UnitDelay3_DSTATE;         /* '<S11>/Unit Delay3' */\r\n} DW;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    struct {\r\n      uint8_T TID[3];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* Model entry point functions */\r\nextern void Flux_Nonsensor_initialize(void);\r\nextern void Flux_Nonsensor_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Add' : Unused code path elimination\r\n * Block '<Root>/Display1' : Unused code path elimination\r\n * Block '<S2>/Constant3' : Unused code path elimination\r\n * Block '<S14>/Scope' : Unused code path elimination\r\n * Block '<S14>/Scope1' : Unused code path elimination\r\n * Block '<S14>/Scope2' : Unused code path elimination\r\n * Block '<S15>/Scope' : Unused code path elimination\r\n * Block '<S15>/Scope1' : Unused code path elimination\r\n * Block '<S17>/Scope' : Unused code path elimination\r\n * Block '<S7>/Scope' : Unused code path elimination\r\n * Block '<S7>/Scope1' : Unused code path elimination\r\n * Block '<S2>/Scope1' : Unused code path elimination\r\n * Block '<S11>/Saturation2' : Unused code path elimination\r\n * Block '<S185>/Abs' : Unused code path elimination\r\n * Block '<S185>/Add' : Unused code path elimination\r\n * Block '<S185>/Product3' : Unused code path elimination\r\n * Block '<S185>/Product4' : Unused code path elimination\r\n * Block '<S186>/Add' : Unused code path elimination\r\n * Block '<S186>/Add2' : Unused code path elimination\r\n * Block '<S186>/Add4' : Unused code path elimination\r\n * Block '<S186>/Constant' : Unused code path elimination\r\n * Block '<S186>/Gain' : Unused code path elimination\r\n * Block '<S186>/Gain1' : Unused code path elimination\r\n * Block '<S186>/Gain2' : Unused code path elimination\r\n * Block '<S191>/Constant' : Unused code path elimination\r\n * Block '<S191>/Mod' : Unused code path elimination\r\n * Block '<S191>/polepair' : Unused code path elimination\r\n * Block '<S186>/Product' : Unused code path elimination\r\n * Block '<S186>/Product1' : Unused code path elimination\r\n * Block '<S186>/Product11' : Unused code path elimination\r\n * Block '<S186>/Product12' : Unused code path elimination\r\n * Block '<S186>/Product2' : Unused code path elimination\r\n * Block '<S186>/Product3' : Unused code path elimination\r\n * Block '<S186>/Product4' : Unused code path elimination\r\n * Block '<Root>/Scope' : Unused code path elimination\r\n * Block '<Root>/Scope1' : Unused code path elimination\r\n * Block '<Root>/Scope14' : Unused code path elimination\r\n * Block '<Root>/Scope15' : Unused code path elimination\r\n * Block '<Root>/Scope16' : Unused code path elimination\r\n * Block '<Root>/Scope17' : Unused code path elimination\r\n * Block '<Root>/Scope2' : Unused code path elimination\r\n * Block '<Root>/Scope3' : Unused code path elimination\r\n * Block '<Root>/Scope4' : Unused code path elimination\r\n * Block '<Root>/Scope5' : Unused code path elimination\r\n * Block '<Root>/Scope6' : Unused code path elimination\r\n * Block '<Root>/Scope7' : Unused code path elimination\r\n * Block '<S7>/Gain' : Eliminated nontunable gain of 1\r\n * Block '<S7>/Gain1' : Eliminated nontunable gain of 1\r\n * Block '<S7>/Gain2' : Eliminated nontunable gain of 1\r\n * Block '<S7>/Gain3' : Eliminated nontunable gain of 1\r\n * Block '<S2>/Manual Switch' : Eliminated due to constant selection input\r\n * Block '<S2>/Signal Conversion3' : Eliminate redundant signal conversion block\r\n * Block '<S2>/Signal Conversion4' : Eliminate redundant signal conversion block\r\n * Block '<S2>/Signal Conversion5' : Eliminate redundant signal conversion block\r\n * Block '<Root>/Rate Transition10' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Rate Transition4' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Rate Transition5' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Rate Transition6' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Rate Transition7' : Eliminated since input and output rates are identical\r\n * Block '<S1>/Constant' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Flux_Nonsensor'\r\n * '<S1>'   : 'Flux_Nonsensor/Average-Value Inverter'\r\n * '<S2>'   : 'Flux_Nonsensor/FOC电机控制'\r\n * '<S3>'   : 'Flux_Nonsensor/Interior PMSM'\r\n * '<S4>'   : 'Flux_Nonsensor/RangeLimit'\r\n * '<S5>'   : 'Flux_Nonsensor/Subsystem'\r\n * '<S6>'   : 'Flux_Nonsensor/FOC电机控制/Clark'\r\n * '<S7>'   : 'Flux_Nonsensor/FOC电机控制/Flux_Observer'\r\n * '<S8>'   : 'Flux_Nonsensor/FOC电机控制/InvPark'\r\n * '<S9>'   : 'Flux_Nonsensor/FOC电机控制/Park'\r\n * '<S10>'  : 'Flux_Nonsensor/FOC电机控制/SVPWM1'\r\n * '<S11>'  : 'Flux_Nonsensor/FOC电机控制/speed_control'\r\n * '<S12>'  : 'Flux_Nonsensor/FOC电机控制/电流环'\r\n * '<S13>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER'\r\n * '<S14>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/Cacl_Flux'\r\n * '<S15>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL'\r\n * '<S16>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller'\r\n * '<S17>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Sine_Cosine'\r\n * '<S18>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/integrator'\r\n * '<S19>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Anti-windup'\r\n * '<S20>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/D Gain'\r\n * '<S21>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/External Derivative'\r\n * '<S22>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Filter'\r\n * '<S23>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Filter ICs'\r\n * '<S24>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/I Gain'\r\n * '<S25>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Ideal P Gain'\r\n * '<S26>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Ideal P Gain Fdbk'\r\n * '<S27>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Integrator'\r\n * '<S28>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Integrator ICs'\r\n * '<S29>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/N Copy'\r\n * '<S30>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/N Gain'\r\n * '<S31>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/P Copy'\r\n * '<S32>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Parallel P Gain'\r\n * '<S33>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Reset Signal'\r\n * '<S34>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Saturation'\r\n * '<S35>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Saturation Fdbk'\r\n * '<S36>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Sum'\r\n * '<S37>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Sum Fdbk'\r\n * '<S38>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tracking Mode'\r\n * '<S39>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tracking Mode Sum'\r\n * '<S40>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tsamp - Integral'\r\n * '<S41>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tsamp - Ngain'\r\n * '<S42>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/postSat Signal'\r\n * '<S43>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/preSat Signal'\r\n * '<S44>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel'\r\n * '<S45>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S46>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S47>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/D Gain/Disabled'\r\n * '<S48>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/External Derivative/Disabled'\r\n * '<S49>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Filter/Disabled'\r\n * '<S50>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Filter ICs/Disabled'\r\n * '<S51>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/I Gain/External Parameters'\r\n * '<S52>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Ideal P Gain/Passthrough'\r\n * '<S53>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S54>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Integrator/Discrete'\r\n * '<S55>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Integrator ICs/Internal IC'\r\n * '<S56>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/N Copy/Disabled wSignal Specification'\r\n * '<S57>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/N Gain/Disabled'\r\n * '<S58>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/P Copy/Disabled'\r\n * '<S59>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Parallel P Gain/External Parameters'\r\n * '<S60>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Reset Signal/Disabled'\r\n * '<S61>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Saturation/Enabled'\r\n * '<S62>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Saturation Fdbk/Disabled'\r\n * '<S63>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Sum/Sum_PI'\r\n * '<S64>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Sum Fdbk/Disabled'\r\n * '<S65>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tracking Mode/Disabled'\r\n * '<S66>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S67>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S68>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S69>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/postSat Signal/Forward_Path'\r\n * '<S70>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/Discrete PID Controller/preSat Signal/Forward_Path'\r\n * '<S71>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/integrator/Angle_Limit'\r\n * '<S72>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/integrator/Angle_Limit/If Action Subsystem1'\r\n * '<S73>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/integrator/Angle_Limit/If Action Subsystem2'\r\n * '<S74>'  : 'Flux_Nonsensor/FOC电机控制/Flux_Observer/Flux_OBSERVER/PLL/integrator/Angle_Limit/If Action Subsystem3'\r\n * '<S75>'  : 'Flux_Nonsensor/FOC电机控制/SVPWM1/InvClark'\r\n * '<S76>'  : 'Flux_Nonsensor/FOC电机控制/SVPWM1/ei_t'\r\n * '<S77>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller'\r\n * '<S78>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1'\r\n * '<S79>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Anti-windup'\r\n * '<S80>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/D Gain'\r\n * '<S81>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/External Derivative'\r\n * '<S82>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Filter'\r\n * '<S83>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Filter ICs'\r\n * '<S84>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/I Gain'\r\n * '<S85>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Ideal P Gain'\r\n * '<S86>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Ideal P Gain Fdbk'\r\n * '<S87>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Integrator'\r\n * '<S88>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Integrator ICs'\r\n * '<S89>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/N Copy'\r\n * '<S90>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/N Gain'\r\n * '<S91>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/P Copy'\r\n * '<S92>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Parallel P Gain'\r\n * '<S93>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Reset Signal'\r\n * '<S94>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Saturation'\r\n * '<S95>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Saturation Fdbk'\r\n * '<S96>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Sum'\r\n * '<S97>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Sum Fdbk'\r\n * '<S98>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tracking Mode'\r\n * '<S99>'  : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tracking Mode Sum'\r\n * '<S100>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tsamp - Integral'\r\n * '<S101>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tsamp - Ngain'\r\n * '<S102>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/postSat Signal'\r\n * '<S103>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/preSat Signal'\r\n * '<S104>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel'\r\n * '<S105>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S106>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S107>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/D Gain/Disabled'\r\n * '<S108>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/External Derivative/Disabled'\r\n * '<S109>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Filter/Disabled'\r\n * '<S110>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Filter ICs/Disabled'\r\n * '<S111>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/I Gain/External Parameters'\r\n * '<S112>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Ideal P Gain/Passthrough'\r\n * '<S113>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S114>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Integrator/Discrete'\r\n * '<S115>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Integrator ICs/Internal IC'\r\n * '<S116>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/N Copy/Disabled wSignal Specification'\r\n * '<S117>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/N Gain/Disabled'\r\n * '<S118>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/P Copy/Disabled'\r\n * '<S119>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Parallel P Gain/External Parameters'\r\n * '<S120>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Reset Signal/Disabled'\r\n * '<S121>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Saturation/Enabled'\r\n * '<S122>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Saturation Fdbk/Disabled'\r\n * '<S123>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Sum/Sum_PI'\r\n * '<S124>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Sum Fdbk/Disabled'\r\n * '<S125>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tracking Mode/Disabled'\r\n * '<S126>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S127>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S128>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S129>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/postSat Signal/Forward_Path'\r\n * '<S130>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller/preSat Signal/Forward_Path'\r\n * '<S131>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Anti-windup'\r\n * '<S132>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/D Gain'\r\n * '<S133>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/External Derivative'\r\n * '<S134>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Filter'\r\n * '<S135>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Filter ICs'\r\n * '<S136>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/I Gain'\r\n * '<S137>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Ideal P Gain'\r\n * '<S138>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Ideal P Gain Fdbk'\r\n * '<S139>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Integrator'\r\n * '<S140>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Integrator ICs'\r\n * '<S141>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/N Copy'\r\n * '<S142>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/N Gain'\r\n * '<S143>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/P Copy'\r\n * '<S144>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Parallel P Gain'\r\n * '<S145>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Reset Signal'\r\n * '<S146>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Saturation'\r\n * '<S147>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Saturation Fdbk'\r\n * '<S148>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Sum'\r\n * '<S149>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Sum Fdbk'\r\n * '<S150>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tracking Mode'\r\n * '<S151>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tracking Mode Sum'\r\n * '<S152>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tsamp - Integral'\r\n * '<S153>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tsamp - Ngain'\r\n * '<S154>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/postSat Signal'\r\n * '<S155>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/preSat Signal'\r\n * '<S156>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n * '<S157>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S158>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S159>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/D Gain/Disabled'\r\n * '<S160>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/External Derivative/Disabled'\r\n * '<S161>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Filter/Disabled'\r\n * '<S162>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Filter ICs/Disabled'\r\n * '<S163>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/I Gain/External Parameters'\r\n * '<S164>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Ideal P Gain/Passthrough'\r\n * '<S165>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n * '<S166>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Integrator/Discrete'\r\n * '<S167>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Integrator ICs/Internal IC'\r\n * '<S168>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/N Copy/Disabled wSignal Specification'\r\n * '<S169>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/N Gain/Disabled'\r\n * '<S170>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/P Copy/Disabled'\r\n * '<S171>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Parallel P Gain/External Parameters'\r\n * '<S172>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Reset Signal/Disabled'\r\n * '<S173>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Saturation/Enabled'\r\n * '<S174>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Saturation Fdbk/Disabled'\r\n * '<S175>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Sum/Sum_PI'\r\n * '<S176>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Sum Fdbk/Disabled'\r\n * '<S177>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tracking Mode/Disabled'\r\n * '<S178>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tracking Mode Sum/Passthrough'\r\n * '<S179>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tsamp - Integral/TsSignalSpecification'\r\n * '<S180>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/Tsamp - Ngain/Passthrough'\r\n * '<S181>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/postSat Signal/Forward_Path'\r\n * '<S182>' : 'Flux_Nonsensor/FOC电机控制/电流环/Discrete PID Controller1/preSat Signal/Forward_Path'\r\n * '<S183>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete'\r\n * '<S184>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete'\r\n * '<S185>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Mechanical and Angle'\r\n * '<S186>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1'\r\n * '<S187>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic'\r\n * '<S188>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Mechanical and Angle/Int1'\r\n * '<S189>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Mechanical and Angle/Int1/Compare To Constant'\r\n * '<S190>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Mechanical and Angle/Int1/Compare To Constant1'\r\n * '<S191>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1/MechToElect'\r\n * '<S192>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1/Power Accounting Bus Creator'\r\n * '<S193>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1/Power Accounting Bus Creator/PwrNotTrnsfrd Input'\r\n * '<S194>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1/Power Accounting Bus Creator/PwrStored Input'\r\n * '<S195>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/Motor Units1/Power Accounting Bus Creator/PwrTrnsfrd Input'\r\n * '<S196>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Clarke Transform'\r\n * '<S197>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Inverse Clarke Transform'\r\n * '<S198>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Inverse Park Transform'\r\n * '<S199>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Machine Torque'\r\n * '<S200>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit'\r\n * '<S201>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Park Transform'\r\n * '<S202>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/Machine Torque/Subsystem'\r\n * '<S203>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/D Axis Stator Voltage'\r\n * '<S204>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/Q Axis Stator Voltage'\r\n * '<S205>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/D Axis Stator Voltage/Subsystem'\r\n * '<S206>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/D Axis Stator Voltage/Subsystem1'\r\n * '<S207>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/D Axis Stator Voltage/Subsystem2'\r\n * '<S208>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/Q Axis Stator Voltage/Subsystem'\r\n * '<S209>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/Q Axis Stator Voltage/Subsystem1'\r\n * '<S210>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/Q Axis Stator Voltage/Subsystem2'\r\n * '<S211>' : 'Flux_Nonsensor/Interior PMSM/PMSM Torque Input Discrete/PMSM Torque Input Core Discrete/PMSM Electromagnetic/PMSM Equivalent Circuit/Q Axis Stator Voltage/Subsystem3'\r\n * '<S212>' : 'Flux_Nonsensor/RangeLimit/If Action Subsystem'\r\n * '<S213>' : 'Flux_Nonsensor/RangeLimit/If Action Subsystem1'\r\n * '<S214>' : 'Flux_Nonsensor/RangeLimit/If Action Subsystem2'\r\n */\r\n#endif                                 /* Flux_Nonsensor_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Flux_Nonsensor_private.h","type":"header","group":"model","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * File: Flux_Nonsensor_private.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef Flux_Nonsensor_private_h_\r\n#define Flux_Nonsensor_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"Flux_Nonsensor.h\"\r\n#include \"Flux_Nonsensor_types.h\"\r\n\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\nextern void InvPark(real32_T rtu_d, real32_T rtu_q, const real32_T rtu_SinCos[2],\r\n                    real32_T *rty_alpha, real32_T *rty_beta);\r\nextern void Park(real32_T rtu_Alpha, real32_T rtu_Beta, const real32_T\r\n                 rtu_SinCos[2], real32_T *rty_D, real32_T *rty_Q);\r\nextern void SVPWM1(real32_T rtu_Valpha, real32_T rtu_Vbeta, real32_T rtu_v_bus,\r\n                   real32_T rty_tABC[3]);\r\nextern void u(real32_T rtu_IRefD, real32_T rtu_ISensD, real32_T rtu_IRefQ,\r\n              real32_T rtu_ISensQ, real32_T *rty_PIOutputVd, real32_T\r\n              *rty_PIOutputVq, DW_u *localDW);\r\nextern void Sine_Cosine(void);\r\n\r\n#endif                                 /* Flux_Nonsensor_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Flux_Nonsensor_types.h","type":"header","group":"model","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * File: Flux_Nonsensor_types.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef Flux_Nonsensor_types_h_\r\n#define Flux_Nonsensor_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n#endif                                 /* Flux_Nonsensor_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"speed_control.c","type":"source","group":"subsystem","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"子系统文件","code":"/*\r\n * File: speed_control.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"speed_control.h\"\r\n#include \"Flux_Nonsensor.h\"\r\n#include \"global_mcu_adc_isr.h\"\r\n\r\n/* Output and update for atomic system: '<S2>/speed_control' */\r\nreal32_T speed_control(real32_T rtu_Obs_Speed)\r\n{\r\n  real32_T rty_Iq_ref_0;\r\n  real32_T rtb_Switch;\r\n\r\n  /* Sum: '<S11>/Sum' */\r\n  rtb_Switch = Speed_target - rtu_Obs_Speed;\r\n\r\n  /* DiscreteIntegrator: '<S11>/Discrete-Time Integrator' */\r\n  if (rtDW.DiscreteTimeIntegrator_PrevResetState != 0) {\r\n    rtDW.DiscreteTimeIntegrator_DSTATE_k = 0.0F;\r\n  }\r\n\r\n  /* Sum: '<S11>/Add' incorporates:\r\n   *  Constant: '<S11>/Kp'\r\n   *  DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\r\n   *  Product: '<S11>/Product'\r\n   */\r\n  rty_Iq_ref_0 = Speed_Kp * rtb_Switch + rtDW.DiscreteTimeIntegrator_DSTATE_k;\r\n\r\n  /* Switch: '<S11>/Switch' incorporates:\r\n   *  Constant: '<S11>/Cons'\r\n   *  UnitDelay: '<S11>/Unit Delay3'\r\n   */\r\n  if (!rtDW.UnitDelay3_DSTATE) {\r\n    rtb_Switch = 0.0F;\r\n  }\r\n\r\n  /* Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator' incorporates:\r\n   *  Constant: '<S11>/Ki'\r\n   *  Product: '<S11>/Product1'\r\n   *  Switch: '<S11>/Switch'\r\n   */\r\n  rtDW.DiscreteTimeIntegrator_DSTATE_k += Speed_Ki * rtb_Switch * 0.0001F;\r\n  rtDW.DiscreteTimeIntegrator_PrevResetState = 0;\r\n\r\n  /* Update for UnitDelay: '<S11>/Unit Delay3' incorporates:\r\n   *  RelationalOperator: '<S11>/Relational Operator1'\r\n   */\r\n  rtDW.UnitDelay3_DSTATE = (rty_Iq_ref_0 == rty_Iq_ref_0);\r\n  return rty_Iq_ref_0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"speed_control.h","type":"header","group":"subsystem","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"子系统文件","code":"/*\r\n * File: speed_control.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef speed_control_h_\r\n#define speed_control_h_\r\n#ifndef Flux_Nonsensor_COMMON_INCLUDES_\r\n#define Flux_Nonsensor_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* Flux_Nonsensor_COMMON_INCLUDES_ */\r\n\r\nextern real32_T speed_control(real32_T rtu_Obs_Speed);\r\n\r\n#endif                                 /* speed_control_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_Motor_Control_data.c","type":"source","group":"data","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"数据文件","code":"/*\r\n * File: FOC_Motor_Control_data.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"global_mcu_adc_isr.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Flux_Nonsensor_types.h\"\r\n\r\n/* Exported data definition */\r\n\r\n/* Definition for custom storage class: Global */\r\nreal32_T Gamma = 100000.0F;            /* Referenced by: '<S14>/Constant3' */\r\nreal32_T Speed_Ki = 0.156051531F;      /* Referenced by: '<S11>/Ki' */\r\nreal32_T Speed_Kp = 0.031210307F;      /* Referenced by: '<S11>/Kp' */\r\nreal32_T pll_omega = 10000.0F;         /* Referenced by: '<S15>/Constant2' */\r\nreal32_T pll_xi = 1.0E+6F;             /* Referenced by: '<S15>/Constant3' */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"global_mcu_adc_isr.c","type":"source","group":"data","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"数据文件","code":"/*\r\n * File: global_mcu_adc_isr.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"global_mcu_adc_isr.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Flux_Nonsensor_types.h\"\r\n\r\n/* Exported data definition */\r\n\r\n/* Definition for custom storage class: Global */\r\nreal32_T Bus_voltage;                  /* '<Root>/Data Type Conversion4' */\r\nreal32_T Id_measured;                  /* '<S2>/Park' */\r\nreal32_T Iq_measured;                  /* '<S2>/Park' */\r\nreal32_T ObserverTheta;                /* '<S18>/Unit Delay' */\r\nreal32_T Phase_CurrentA;               /* '<Root>/Data Type Conversion' */\r\nreal32_T Phase_CurrentB;               /* '<Root>/Data Type Conversion1' */\r\nreal32_T Phase_CurrentC;               /* '<Root>/Data Type Conversion2' */\r\nreal32_T Speed_target;                 /* '<Root>/Data Type Conversion6' */\r\nreal32_T Theta;                        /* '<Root>/Data Type Conversion3' */\r\nreal32_T Vd_voltage;                   /* '<S2>/电流环' */\r\nreal32_T Vq_voltage;                   /* '<S2>/电流环' */\r\nreal32_T err;                          /* '<S14>/Add2' */\r\nreal32_T speed;                        /* '<Root>/Data Type Conversion5' */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"global_mcu_adc_isr.h","type":"header","group":"data","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"数据文件","code":"/*\r\n * File: global_mcu_adc_isr.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef global_mcu_adc_isr_h_\r\n#define global_mcu_adc_isr_h_\r\n#include \"rtwtypes.h\"\r\n#include \"Flux_Nonsensor_types.h\"\r\n\r\n/* Exported data declaration */\r\n\r\n/* Declaration for custom storage class: Global */\r\nextern real32_T Bus_voltage;           /* '<Root>/Data Type Conversion4' */\r\nextern real32_T Id_measured;           /* '<S2>/Park' */\r\nextern real32_T Iq_measured;           /* '<S2>/Park' */\r\nextern real32_T ObserverTheta;         /* '<S18>/Unit Delay' */\r\nextern real32_T Phase_CurrentA;        /* '<Root>/Data Type Conversion' */\r\nextern real32_T Phase_CurrentB;        /* '<Root>/Data Type Conversion1' */\r\nextern real32_T Phase_CurrentC;        /* '<Root>/Data Type Conversion2' */\r\nextern real32_T Speed_target;          /* '<Root>/Data Type Conversion6' */\r\nextern real32_T Theta;                 /* '<Root>/Data Type Conversion3' */\r\nextern real32_T Vd_voltage;            /* '<S2>/电流环' */\r\nextern real32_T Vq_voltage;            /* '<S2>/电流环' */\r\nextern real32_T err;                   /* '<S14>/Add2' */\r\nextern real32_T speed;                 /* '<Root>/Data Type Conversion5' */\r\n\r\n/* Declaration for custom storage class: Global */\r\nextern real32_T Gamma;                 /* Referenced by: '<S14>/Constant3' */\r\nextern real32_T Speed_Ki;              /* Referenced by: '<S11>/Ki' */\r\nextern real32_T Speed_Kp;              /* Referenced by: '<S11>/Kp' */\r\nextern real32_T pll_omega;             /* Referenced by: '<S15>/Constant2' */\r\nextern real32_T pll_xi;                /* Referenced by: '<S15>/Constant3' */\r\n\r\n#endif                                 /* global_mcu_adc_isr_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetInf_h_\r\n#define rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\matlabFile\\4.非线性磁链观测无感\\test\\Flux_Nonsensor_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'Flux_Nonsensor'.\r\n *\r\n * Model version                  : 8.14\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Dec 21 22:28:59 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: NXP->Cortex-M4\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};